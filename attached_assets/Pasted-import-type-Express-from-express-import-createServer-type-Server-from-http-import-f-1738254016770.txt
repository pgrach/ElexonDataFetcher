import type { Express } from "express";
import { createServer, type Server } from "http";
import { fetchCurtailmentData } from './services/elexon';
import { calculatePotentialBtc } from './services/bitcoin';
import { generateUnknownBmuReport, addUnknownBmu } from './services/reporting';
import bitcoinRouter from './routes/bitcoin';
import type { AggregatedData, DailySummary, TopCurtailedFarm, GroupedFarm, FarmDetail } from './types';
import bmuMapping from '../client/src/data/bmuMapping.json';
import { startOfMonth, endOfMonth, eachDayOfInterval, format } from 'date-fns';

// Create a Map for efficient BMU lookups
const bmuLookup = new Map(
  bmuMapping.map(bmu => [bmu.elexonBmUnit, bmu.leadPartyName])
);

// Cache for API responses
const apiCache = new Map<string, { data: any, timestamp: number }>();
const CACHE_DURATION = 5 * 60 * 1000; // 5 minutes

// Helper function to get cached data or fetch new data
async function getCachedData(date: string, period: number) {
  const cacheKey = `${date}-${period}`;
  const cachedResult = apiCache.get(cacheKey);

  if (cachedResult && (Date.now() - cachedResult.timestamp) < CACHE_DURATION) {
    return cachedResult.data;
  }

  const data = await fetchCurtailmentData(date, period);
  apiCache.set(cacheKey, { data, timestamp: Date.now() });
  return data;
}

async function aggregateTopFarms(periodData: any[], date?: string, minerModel: string = 'S19J_PRO'): Promise<GroupedFarm[]> {
  // First, aggregate data by individual farms
  const farmMap = new Map<string, { volume: number, payment: number }>();
  let totalCurtailment = 0;

  periodData.flat().forEach(data => {
    const current = farmMap.get(data.farmId) || { volume: 0, payment: 0 };
    farmMap.set(data.farmId, {
      volume: current.volume + data.volume,
      payment: current.payment + (data.payment || 0)
    });
    totalCurtailment += data.volume;
  });

  // Convert to array and calculate BTC mining potential for each farm
  const farmPromises = Array.from(farmMap.entries()).map(async ([farmId, { volume, payment }]) => {
    const potentialBtc = await calculatePotentialBtc(volume, date ? new Date(date) : undefined, minerModel);
    return {
      farmId,
      curtailedEnergy: volume,
      percentageOfTotal: (volume / totalCurtailment) * 100,
      potentialBtc,
      payment,
      leadPartyName: bmuLookup.get(farmId) || 'Unknown'
    };
  });

  const farms = await Promise.all(farmPromises);

  // Group farms by leadPartyName
  const groupedFarmsMap = new Map<string, GroupedFarm>();

  farms.forEach(farm => {
    const existing = groupedFarmsMap.get(farm.leadPartyName) || {
      leadPartyName: farm.leadPartyName,
      totalCurtailedEnergy: 0,
      totalPercentageOfTotal: 0,
      totalPotentialBtc: 0,
      totalPayment: 0,
      farms: []
    };

    const farmDetail: FarmDetail = {
      farmId: farm.farmId,
      curtailedEnergy: farm.curtailedEnergy,
      percentageOfTotal: farm.percentageOfTotal,
      potentialBtc: farm.potentialBtc,
      payment: farm.payment
    };

    existing.totalCurtailedEnergy += farm.curtailedEnergy;
    existing.totalPercentageOfTotal += farm.percentageOfTotal;
    existing.totalPotentialBtc += farm.potentialBtc;
    existing.totalPayment += farm.payment;
    existing.farms.push(farmDetail);

    groupedFarmsMap.set(farm.leadPartyName, existing);
  });

  // Convert to array and sort by total curtailed energy
  return Array.from(groupedFarmsMap.values())
    .sort((a, b) => b.totalCurtailedEnergy - a.totalCurtailedEnergy);
}

export function registerRoutes(app: Express): Server {
  // Register bitcoin routes
  app.use('/api/bitcoin', bitcoinRouter);

  // Add new endpoint for BMU reporting
  app.get('/api/reporting/unknown-bmus', async (req, res) => {
    try {
      const report = await generateUnknownBmuReport();
      res.json({ report });
    } catch (error) {
      console.error('Error generating unknown BMU report:', error);
      res.status(500).json({ error: 'Failed to generate unknown BMU report' });
    }
  });

  // Get daily summary of curtailment and potential BTC mining
  app.get('/api/summary/:date', async (req, res) => {
    try {
      const { date } = req.params;
      const minerModel = (req.query.minerModel as 'S9' | 'S19J_PRO' | 'M20S') || 'S19J_PRO';

      const allPeriodData = await Promise.all(
        Array.from({length: 48}, (_, i) => i + 1)
          .map(period => fetchCurtailmentData(date, period))
      );

      // Log the data before aggregation
      console.log('First period data sample:', allPeriodData[0]);

      // Aggregate half-hourly data into hourly data
      const hourlyPromises = Array.from({length: 24}, async (_, hour) => {
        const periodStart = hour * 2;
        const periodsData = allPeriodData.slice(periodStart, periodStart + 2).flat();

        // Add detailed logging for hour 12
        if (hour === 12) {
          console.log(`\nDetailed calculation for Hour 12 (12:00-13:00):`);
          console.log(`Using Settlement Periods ${periodStart + 1}-${periodStart + 2}`);
          console.log('Period data:', JSON.stringify(periodsData, null, 2));
          console.log('Individual volumes:', periodsData.map(d => d.volume));
          console.log('Individual payments:', periodsData.map(d => d.payment));
          console.log('Total volume:', periodsData.reduce((sum, data) => sum + data.volume, 0));
          console.log('Total payment:', periodsData.reduce((sum, data) => sum + (data.payment || 0), 0));
        }

        const curtailedEnergy = periodsData.reduce((sum, data) => sum + data.volume, 0);
        const totalPayment = periodsData.reduce((sum, data) => sum + (data.payment || 0), 0);
        const potentialBtc = await calculatePotentialBtc(curtailedEnergy, new Date(date), minerModel);

        return {
          hour,
          curtailedEnergy,
          potentialBtc,
          totalPayment
        };
      });

      const hourlyData: AggregatedData[] = await Promise.all(hourlyPromises);

      const summary: DailySummary = {
        date,
        totalCurtailedEnergy: hourlyData.reduce((sum, data) => sum + data.curtailedEnergy, 0),
        totalPotentialBtc: hourlyData.reduce((sum, data) => sum + data.potentialBtc, 0),
        totalPayment: hourlyData.reduce((sum, data) => sum + data.totalPayment, 0),
        hourlyData
      };

      res.json(summary);
    } catch (error) {
      console.error('Error in /api/summary:', error);
      res.status(500).json({ error: 'Failed to fetch curtailment data' });
    }
  });

  // Updated endpoint for top curtailed farms
  app.get('/api/top-farms/:date', async (req, res) => {
    try {
      const { date } = req.params;
      const minerModel = (req.query.minerModel as string) || 'S19J_PRO';

      const allPeriodData = await Promise.all(
        Array.from({length: 48}, (_, i) => i + 1)
          .map(period => fetchCurtailmentData(date, period))
      );

      const groupedFarms = await aggregateTopFarms(allPeriodData, date, minerModel);
      res.json({ farms: groupedFarms });
    } catch (error) {
      console.error('Error in /api/top-farms:', error);
      res.status(500).json({ error: 'Failed to fetch top curtailed farms data' });
    }
  });

  // Updated endpoint for monthly aggregation with optimized fetching
  app.get('/api/summary/monthly/:date', async (req, res) => {
    try {
      const { date } = req.params;
      const startDate = startOfMonth(new Date(date));
      const endDate = endOfMonth(new Date(date));

      console.log(`Fetching monthly summary from ${format(startDate, 'yyyy-MM-dd')} to ${format(endDate, 'yyyy-MM-dd')}`);

      // Get all days in the month
      const daysInMonth = eachDayOfInterval({ start: startDate, end: endDate });

      // Split the month into smaller chunks to avoid timeouts
      const CHUNK_SIZE = 5; // Process 5 days at a time
      const chunks = [];

      for (let i = 0; i < daysInMonth.length; i += CHUNK_SIZE) {
        chunks.push(daysInMonth.slice(i, i + CHUNK_SIZE));
      }

      let allData: any[] = [];

      // Process chunks sequentially to avoid overwhelming the API
      for (const chunk of chunks) {
        const chunkData = await Promise.all(
          chunk.map(async (day) => {
            const formattedDate = format(day, 'yyyy-MM-dd');
            // Fetch data for each day with caching
            const dailyData = await Promise.all(
              Array.from({ length: 48 }, (_, i) => i + 1)
                .map(period => getCachedData(formattedDate, period))
            );
            return dailyData.flat();
          })
        );
        allData = [...allData, ...chunkData.flat()];

        // Add a small delay between chunks to prevent rate limiting
        if (chunks.indexOf(chunk) < chunks.length - 1) {
          await new Promise(resolve => setTimeout(resolve, 1000));
        }
      }

      const monthlySummary = {
        totalCurtailedEnergy: allData.reduce((sum, data) => sum + data.volume, 0),
        totalPayment: allData.reduce((sum, data) => sum + (data.payment || 0), 0),
      };

      res.json(monthlySummary);
    } catch (error) {
      console.error('Error in /api/summary/monthly:', error);
      res.status(500).json({ error: 'Failed to fetch monthly curtailment data' });
    }
  });

  const httpServer = createServer(app);
  return httpServer;
}